{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","source/curryOnTop.js","curryOnTop.js","source/functional.js","source/iteration.js","source/methodCurry.js","source/tuple.js"],"names":["e","exports","module","define","amd","f","window","global","self","curryOnTop","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,"fn","iteration","methodCurry","tuple","selectTuplesWithFunctions","select","isValueAFunction","selectFunctionTuplesFromObject","compose","toTuples","curryLeftTupleMethods","map","curryMethodLeft","curryRightTupleMethods","curryMethodRight","curryObjectMethodsLeft","toObject","curryObjectMethodsRight","functional","left","right","singleLeftWithArity","curryMethodLeftWithArity","singleRightWithArity","curryMethodRightWithArity","singleLeft","singleRight","./functional","./iteration","./methodCurry","./tuple",2,"currylessSlice","arr","start","end","slice","currylessReverse","reverse","currylessIdentity","value","curryLessExists","obj","funcs","toArray","arguments","func","args","index","apply","noop","curryExecuteNext","processArgs","arity","this","newArgs","nextArgs","concat","curryRight","curry","others","undefined","rest","negate","predicate","identity","constant","exists","truthy","falsy","isOfType","type","isFunction","constructor","isObject","Boolean","isString","isNumber","isNaN","isBoolean","prop","key",3,"fold","iterator","initial","items","memo","hasOwnProperty","result","push","tuples","selection",4,"executeMethod","context","method","curryMethodInDirection","curried",5,"getKey","getValue","toTuple","curryMethod"],"mappings":"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","file":"curryOnTop.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","\"use strict\";\n\nvar fn = require(\"./functional\");\nvar iteration = require(\"./iteration\");\nvar methodCurry = require(\"./methodCurry\");\nvar tuple = require(\"./tuple\");\n\nvar selectTuplesWithFunctions = iteration.select(tuple.isValueAFunction);\n\nvar selectFunctionTuplesFromObject = fn.compose(selectTuplesWithFunctions, tuple.toTuples);\n\nvar curryLeftTupleMethods = iteration.map(tuple.curryMethodLeft);\nvar curryRightTupleMethods = iteration.map(tuple.curryMethodRight);\n\nvar curryObjectMethodsLeft =\n\t\tfn.compose(tuple.toObject, curryLeftTupleMethods, selectFunctionTuplesFromObject);\n\nvar curryObjectMethodsRight =\n\t\tfn.compose(tuple.toObject, curryRightTupleMethods, selectFunctionTuplesFromObject);\n\n\n// Build the export object\nvar curryOnTop = {\n\tfunctional: fn,\n\tleft: curryObjectMethodsLeft,\n\tright: curryObjectMethodsRight,\n\tsingleLeftWithArity: methodCurry.curryMethodLeftWithArity,\n\tsingleRightWithArity: methodCurry.curryMethodRightWithArity,\n\tsingleLeft: methodCurry.curryMethodLeft,\n\tsingleRight: methodCurry.curryMethodRight\n};\n\nmodule.exports = curryOnTop;","!function(e){if(\"object\"==typeof exports&&\"undefined\"!=typeof module)module.exports=e();else if(\"function\"==typeof define&&define.amd)define([],e);else{var f;\"undefined\"!=typeof window?f=window:\"undefined\"!=typeof global?f=global:\"undefined\"!=typeof self&&(f=self),f.curryOnTop=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n\"use strict\";\n\nvar fn = require(\"./functional\");\nvar iteration = require(\"./iteration\");\nvar methodCurry = require(\"./methodCurry\");\nvar tuple = require(\"./tuple\");\n\nvar selectTuplesWithFunctions = iteration.select(tuple.isValueAFunction);\n\nvar selectFunctionTuplesFromObject = fn.compose(selectTuplesWithFunctions, tuple.toTuples);\n\nvar curryLeftTupleMethods = iteration.map(tuple.curryMethodLeft);\nvar curryRightTupleMethods = iteration.map(tuple.curryMethodRight);\n\nvar curryObjectMethodsLeft =\n\t\tfn.compose(tuple.toObject, curryLeftTupleMethods, selectFunctionTuplesFromObject);\n\nvar curryObjectMethodsRight =\n\t\tfn.compose(tuple.toObject, curryRightTupleMethods, selectFunctionTuplesFromObject);\n\n\n// Build the export object\nvar curryOnTop = {\n\tfunctional: fn,\n\tleft: curryObjectMethodsLeft,\n\tright: curryObjectMethodsRight,\n\tsingleLeftWithArity: methodCurry.curryMethodLeftWithArity,\n\tsingleRightWithArity: methodCurry.curryMethodRightWithArity,\n\tsingleLeft: methodCurry.curryMethodLeft,\n\tsingleRight: methodCurry.curryMethodRight\n};\n\nmodule.exports = curryOnTop;\n},{\"./functional\":2,\"./iteration\":3,\"./methodCurry\":4,\"./tuple\":5}],2:[function(require,module,exports){\n\"use strict\";\n\n\n// These functions are not curried because\n// they are needed for the curry impelmentation.\nfunction currylessSlice(arr, start, end) {\n\treturn [].slice.call(arr, start, end);\n}\n\nfunction currylessReverse(arr) {\n\treturn currylessSlice(arr).reverse();\n}\n\nfunction currylessIdentity(value) {\n\treturn value;\n}\n\nfunction curryLessExists(obj) {\n\treturn obj != null; // jshint ignore:line\n}\n\n\n// Function that does the actual currying.\n// It can be used for currying left or right.\nvar curryExecuteNext = function (processArgs, func, arity, args) {\n\tarity = curryLessExists(arity) ? arity : func.length;\n\tif (args.length >= arity) {\n\t\treturn func.apply(this, processArgs(args));\n\t} else {\n\t\treturn function () {\n\t\t\tvar newArgs = currylessSlice(arguments);\n\t\t\tvar nextArgs = args.concat(newArgs);\n\t\t\treturn curryExecuteNext.call(this, processArgs, func, arity, nextArgs);\n\t\t};\n\t}\n};\n\n\nvar curryRight = function curryRight(func, arity) {\n\treturn curryExecuteNext.call(this, currylessReverse, func, arity, []);\n};\n\n\n// Curry left\nvar curry = function curry(func, arity) {\n\treturn curryExecuteNext.call(this, currylessIdentity, func, arity, []);\n};\n\n\nvar slice = curryRight(currylessSlice);\nvar others = slice(undefined);\nvar toArray = others(0);\nvar rest = others(1);\n\nfunction compose() {\n\tvar funcs = toArray(arguments);\n\n\treturn function composer() {\n\t\tvar args = arguments;\n\t\tvar func;\n\t\tfor (var index = funcs.length - 1; index >= 0; index -= 1) {\n\t\t\tfunc = funcs[index];\n\t\t\targs = [func.apply(null, args)];\n\t\t}\n\n\t\treturn args[0];\n\t};\n}\n\nvar negate = curry(function (predicate) {\n\treturn function () {\n\t\treturn !predicate.apply(this, arguments);\n\t};\n});\n\nvar reverse = curry(currylessReverse);\nvar identity = curry(currylessIdentity);\n\nvar constant = curry(function constant(value) {\n\treturn function () {\n\t\treturn value;\n\t};\n});\n\nfunction noop() {}\n\nvar exists = curry(curryLessExists);\n\nvar truthy = curry(function truthy(obj) {\n\treturn exists(obj) && obj !== false;\n});\n\nvar falsy = negate(truthy);\n\n\n// *** Type determination ***\n\nvar isOfType = curry(function isOfType(type, obj) {\n\treturn typeof obj === type;\n});\n\nvar isFunction = curry(function isFunction(obj) {\n    return !!(obj && obj.constructor && obj.call && obj.apply);\n});\n\nvar isObject = curry(function isObject(obj) {\n    return isFunction(obj) || (Boolean(obj) && isOfType(\"object\", obj));\n});\n\nvar isString = isOfType(\"string\");\nvar isNumber = curry(function (obj) {\n\treturn isOfType(\"number\", obj) && !isNaN(obj);\n});\n\nvar isBoolean = isOfType(\"boolean\");\n\nvar prop = curry(function (key, obj) {\n\treturn obj[key];\n});\n\nmodule.exports = {\n\treverse: reverse,\n\tidentity: identity,\n\tconstant: constant,\n\tnoop: noop,\n\n\texists: exists,\n\tnegate: negate,\n\ttruthy: truthy,\n\tfalsy: falsy,\n\n\tisFunction: isFunction,\n\tisObject: isObject,\n\tisString: isString,\n\tisNumber: isNumber,\n\tisBoolean: isBoolean,\n\n\tslice: slice,\n\tothers: others,\n\trest: rest,\n\ttoArray: toArray,\n\tprop: prop,\n\n\tcurryRight: curryRight,\n\tcurry: curry,\n\n\tcompose: compose\n};\n},{}],3:[function(require,module,exports){\n\"use strict\";\n\nvar fn = require(\"./functional\");\n\nvar fold = fn.curry(function fold(iterator, initial, items) {\n\tvar memo = initial;\n\n\tfor(var key in items) {\n\t\tif (items.hasOwnProperty(key)) {\n\t\t\tmemo = iterator(memo, items[key], key);\n\t\t}\n\t}\n\n\treturn memo;\n});\n\nvar map = fn.curry(function map(iterator, items) {\n\n\treturn fold(function (memo, value, key) {\n\t\t\tvar result = iterator(value, key, items);\n\t\t\tmemo.push(result);\n\n\t\t\treturn memo;\n\t}, [], items);\n});\n\nvar select = fn.curry(function select(iterator, tuples) {\n\treturn fold(function (selection, tuple) {\n\t\tif (iterator(tuple)) {\n\t\t\tselection.push(tuple);\n\t\t}\n\n\t\treturn selection;\n\t}, [], tuples);\n});\n\nmodule.exports = {\n\tfold: fold,\n\tmap: map,\n\tselect: select,\n};\n},{\"./functional\":2}],4:[function(require,module,exports){\n\"use strict\";\n\nvar fn = require(\"./functional\");\n\nvar executeMethod = fn.curry(function executeMethod(context, method, args) {\n\treturn method.apply(context, args);\n});\n\nvar curryMethodInDirection = fn.curry(function curryMethodInDirection(processArgs, arity, method) {\n\tarity = fn.exists(arity) ? arity : method.length;\n\t// Plus 1 because context will be 1 extra argument\n\tarity +=1;\n\n\tvar curried = fn.curryRight(function (context) {\n\t\tvar args = processArgs(fn.rest(arguments));\n\n\t\treturn executeMethod(context, method, args);\n\n\t}, arity);\n\n\treturn curried.apply(null, fn.others(curryMethodInDirection.length, arguments));\n});\n\nvar curryMethodLeftWithArity = curryMethodInDirection(fn.reverse);\nvar curryMethodRightWithArity = curryMethodInDirection(fn.identity);\n\nvar curryMethodLeft = curryMethodLeftWithArity(undefined);\nvar curryMethodRight = curryMethodRightWithArity(undefined);\n\nmodule.exports = {\n\texecuteMethod: executeMethod,\n\tcurryMethodLeftWithArity: curryMethodLeftWithArity,\n\tcurryMethodRightWithArity: curryMethodRightWithArity,\n\tcurryMethodLeft: curryMethodLeft,\n\tcurryMethodRight: curryMethodRight\n};\n},{\"./functional\":2}],5:[function(require,module,exports){\n\"use strict\";\n\nvar fn = require(\"./functional\");\nvar methodCurry = require(\"./methodCurry\");\nvar iteration = require(\"./iteration\");\n\nvar getKey = fn.prop(0);\nvar getValue = fn.prop(1);\nvar isValueAFunction = fn.compose(fn.isFunction, getValue);\n\nvar toTuple = fn.curry(function toTuple(key, value) {\n\treturn [key, value];\n});\n\nvar toTuples = fn.curry(function toTuples(items) {\n\treturn iteration.fold(function (tuples, value, key) {\n\t\ttuples.push(toTuple(key, value));\n\t\treturn tuples;\n\t}, [], items);\n});\n\nvar toObject = fn.curry(function toObject(tuples) {\n\treturn iteration.fold(function (memo, tuple) {\n\t\tmemo[getKey(tuple)] = getValue(tuple);\n\t\treturn memo;\n\t}, {}, tuples);\n});\n\nvar curryMethodInDirection = fn.curry(function curryMethodInDirection(curryMethod, tuple) {\n\tvar key = getKey(tuple);\n\tvar method = curryMethod(getValue(tuple));\n\n\treturn toTuple(key, method);\n});\n\nvar curryMethodLeft = curryMethodInDirection(methodCurry.curryMethodLeft);\nvar curryMethodRight = curryMethodInDirection(methodCurry.curryMethodRight);\n\nmodule.exports = {\n\ttoTuple: toTuple,\n\ttoTuples: toTuples,\n\ttoObject: toObject,\n\tgetKey: getKey,\n\tgetValue: getValue,\n\tisValueAFunction: isValueAFunction,\n\tcurryMethodLeft: curryMethodLeft,\n\tcurryMethodRight: curryMethodRight\n};\n\n},{\"./functional\":2,\"./iteration\":3,\"./methodCurry\":4}]},{},[1])(1)\n});\n\n\n//# sourceMappingURL=curryOnTop.js.map","\"use strict\";\n\n\n// These functions are not curried because\n// they are needed for the curry impelmentation.\nfunction currylessSlice(arr, start, end) {\n\treturn [].slice.call(arr, start, end);\n}\n\nfunction currylessReverse(arr) {\n\treturn currylessSlice(arr).reverse();\n}\n\nfunction currylessIdentity(value) {\n\treturn value;\n}\n\nfunction curryLessExists(obj) {\n\treturn obj != null; // jshint ignore:line\n}\n\n\n// Function that does the actual currying.\n// It can be used for currying left or right.\nvar curryExecuteNext = function (processArgs, func, arity, args) {\n\tarity = curryLessExists(arity) ? arity : func.length;\n\tif (args.length >= arity) {\n\t\treturn func.apply(this, processArgs(args));\n\t} else {\n\t\treturn function () {\n\t\t\tvar newArgs = currylessSlice(arguments);\n\t\t\tvar nextArgs = args.concat(newArgs);\n\t\t\treturn curryExecuteNext.call(this, processArgs, func, arity, nextArgs);\n\t\t};\n\t}\n};\n\n\nvar curryRight = function curryRight(func, arity) {\n\treturn curryExecuteNext.call(this, currylessReverse, func, arity, []);\n};\n\n\n// Curry left\nvar curry = function curry(func, arity) {\n\treturn curryExecuteNext.call(this, currylessIdentity, func, arity, []);\n};\n\n\nvar slice = curryRight(currylessSlice);\nvar others = slice(undefined);\nvar toArray = others(0);\nvar rest = others(1);\n\nfunction compose() {\n\tvar funcs = toArray(arguments);\n\n\treturn function composer() {\n\t\tvar args = arguments;\n\t\tvar func;\n\t\tfor (var index = funcs.length - 1; index >= 0; index -= 1) {\n\t\t\tfunc = funcs[index];\n\t\t\targs = [func.apply(null, args)];\n\t\t}\n\n\t\treturn args[0];\n\t};\n}\n\nvar negate = curry(function (predicate) {\n\treturn function () {\n\t\treturn !predicate.apply(this, arguments);\n\t};\n});\n\nvar reverse = curry(currylessReverse);\nvar identity = curry(currylessIdentity);\n\nvar constant = curry(function constant(value) {\n\treturn function () {\n\t\treturn value;\n\t};\n});\n\nfunction noop() {}\n\nvar exists = curry(curryLessExists);\n\nvar truthy = curry(function truthy(obj) {\n\treturn exists(obj) && obj !== false;\n});\n\nvar falsy = negate(truthy);\n\n\n// *** Type determination ***\n\nvar isOfType = curry(function isOfType(type, obj) {\n\treturn typeof obj === type;\n});\n\nvar isFunction = curry(function isFunction(obj) {\n    return !!(obj && obj.constructor && obj.call && obj.apply);\n});\n\nvar isObject = curry(function isObject(obj) {\n    return isFunction(obj) || (Boolean(obj) && isOfType(\"object\", obj));\n});\n\nvar isString = isOfType(\"string\");\nvar isNumber = curry(function (obj) {\n\treturn isOfType(\"number\", obj) && !isNaN(obj);\n});\n\nvar isBoolean = isOfType(\"boolean\");\n\nvar prop = curry(function (key, obj) {\n\treturn obj[key];\n});\n\nmodule.exports = {\n\treverse: reverse,\n\tidentity: identity,\n\tconstant: constant,\n\tnoop: noop,\n\n\texists: exists,\n\tnegate: negate,\n\ttruthy: truthy,\n\tfalsy: falsy,\n\n\tisFunction: isFunction,\n\tisObject: isObject,\n\tisString: isString,\n\tisNumber: isNumber,\n\tisBoolean: isBoolean,\n\n\tslice: slice,\n\tothers: others,\n\trest: rest,\n\ttoArray: toArray,\n\tprop: prop,\n\n\tcurryRight: curryRight,\n\tcurry: curry,\n\n\tcompose: compose\n};","\"use strict\";\n\nvar fn = require(\"./functional\");\n\nvar fold = fn.curry(function fold(iterator, initial, items) {\n\tvar memo = initial;\n\n\tfor(var key in items) {\n\t\tif (items.hasOwnProperty(key)) {\n\t\t\tmemo = iterator(memo, items[key], key);\n\t\t}\n\t}\n\n\treturn memo;\n});\n\nvar map = fn.curry(function map(iterator, items) {\n\n\treturn fold(function (memo, value, key) {\n\t\t\tvar result = iterator(value, key, items);\n\t\t\tmemo.push(result);\n\n\t\t\treturn memo;\n\t}, [], items);\n});\n\nvar select = fn.curry(function select(iterator, tuples) {\n\treturn fold(function (selection, tuple) {\n\t\tif (iterator(tuple)) {\n\t\t\tselection.push(tuple);\n\t\t}\n\n\t\treturn selection;\n\t}, [], tuples);\n});\n\nmodule.exports = {\n\tfold: fold,\n\tmap: map,\n\tselect: select,\n};","\"use strict\";\n\nvar fn = require(\"./functional\");\n\nvar executeMethod = fn.curry(function executeMethod(context, method, args) {\n\treturn method.apply(context, args);\n});\n\nvar curryMethodInDirection = fn.curry(function curryMethodInDirection(processArgs, arity, method) {\n\tarity = fn.exists(arity) ? arity : method.length;\n\t// Plus 1 because context will be 1 extra argument\n\tarity +=1;\n\n\tvar curried = fn.curryRight(function (context) {\n\t\tvar args = processArgs(fn.rest(arguments));\n\n\t\treturn executeMethod(context, method, args);\n\n\t}, arity);\n\n\treturn curried.apply(null, fn.others(curryMethodInDirection.length, arguments));\n});\n\nvar curryMethodLeftWithArity = curryMethodInDirection(fn.reverse);\nvar curryMethodRightWithArity = curryMethodInDirection(fn.identity);\n\nvar curryMethodLeft = curryMethodLeftWithArity(undefined);\nvar curryMethodRight = curryMethodRightWithArity(undefined);\n\nmodule.exports = {\n\texecuteMethod: executeMethod,\n\tcurryMethodLeftWithArity: curryMethodLeftWithArity,\n\tcurryMethodRightWithArity: curryMethodRightWithArity,\n\tcurryMethodLeft: curryMethodLeft,\n\tcurryMethodRight: curryMethodRight\n};","\"use strict\";\n\nvar fn = require(\"./functional\");\nvar methodCurry = require(\"./methodCurry\");\nvar iteration = require(\"./iteration\");\n\nvar getKey = fn.prop(0);\nvar getValue = fn.prop(1);\nvar isValueAFunction = fn.compose(fn.isFunction, getValue);\n\nvar toTuple = fn.curry(function toTuple(key, value) {\n\treturn [key, value];\n});\n\nvar toTuples = fn.curry(function toTuples(items) {\n\treturn iteration.fold(function (tuples, value, key) {\n\t\ttuples.push(toTuple(key, value));\n\t\treturn tuples;\n\t}, [], items);\n});\n\nvar toObject = fn.curry(function toObject(tuples) {\n\treturn iteration.fold(function (memo, tuple) {\n\t\tmemo[getKey(tuple)] = getValue(tuple);\n\t\treturn memo;\n\t}, {}, tuples);\n});\n\nvar curryMethodInDirection = fn.curry(function curryMethodInDirection(curryMethod, tuple) {\n\tvar key = getKey(tuple);\n\tvar method = curryMethod(getValue(tuple));\n\n\treturn toTuple(key, method);\n});\n\nvar curryMethodLeft = curryMethodInDirection(methodCurry.curryMethodLeft);\nvar curryMethodRight = curryMethodInDirection(methodCurry.curryMethodRight);\n\nmodule.exports = {\n\ttoTuple: toTuple,\n\ttoTuples: toTuples,\n\ttoObject: toObject,\n\tgetKey: getKey,\n\tgetValue: getValue,\n\tisValueAFunction: isValueAFunction,\n\tcurryMethodLeft: curryMethodLeft,\n\tcurryMethodRight: curryMethodRight\n};\n"],"sourceRoot":"/source/"}