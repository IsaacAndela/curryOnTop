{
  "version": 3,
  "sources": [
    "node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "source/curryOnTop.js",
    "source/functional.js",
    "source/iteration.js",
    "source/methodCurry.js",
    "source/tuple.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "\"use strict\";\n\nvar fn = require(\"./functional\");\nvar iteration = require(\"./iteration\");\nvar methodCurry = require(\"./methodCurry\");\nvar tuple = require(\"./tuple\");\n\nvar selectTuplesWithFunctions = iteration.select(tuple.isValueAFunction);\n\nvar selectFunctionTuplesFromObject = fn.compose(selectTuplesWithFunctions, tuple.toTuples);\n\nvar curryLeftTupleMethods = iteration.map(tuple.curryMethodLeft);\nvar curryRightTupleMethods = iteration.map(tuple.curryMethodRight);\n\nvar curryObjectMethodsLeft =\n\t\tfn.compose(tuple.toObject, curryLeftTupleMethods, selectFunctionTuplesFromObject);\n\nvar curryObjectMethodsRight =\n\t\tfn.compose(tuple.toObject, curryRightTupleMethods, selectFunctionTuplesFromObject);\n\n\n// Build the export object\nvar curryOnTop = {\n\tfunctional: fn,\n\tleft: curryObjectMethodsLeft,\n\tright: curryObjectMethodsRight,\n\tsingleLeftWithArity: methodCurry.curryMethodLeftWithArity,\n\tsingleRightWithArity: methodCurry.curryMethodRightWithArity,\n\tsingleLeft: methodCurry.curryMethodLeft,\n\tsingleRight: methodCurry.curryMethodRight\n};\n\nmodule.exports = curryOnTop;",
    "\"use strict\";\n\n\n// These functions are not curried because\n// they are needed for the curry impelmentation.\nfunction currylessSlice(arr, start, end) {\n\treturn [].slice.call(arr, start, end);\n}\n\nfunction currylessReverse(arr) {\n\treturn currylessSlice(arr).reverse();\n}\n\nfunction currylessIdentity(arg) {\n\treturn arg;\n}\n\nfunction curryLessExists(obj) {\n\treturn obj != null; // jshint ignore:line\n}\n\n\n// Function that does the actual currying.\n// It can be used for currying left or right.\nvar curryExecuteNext = function (processArgs, func, arity, args) {\n\tarity = curryLessExists(arity) ? arity : func.length;\n\tif (args.length >= arity) {\n\t\treturn func.apply(this, processArgs(args));\n\t} else {\n\t\treturn function () {\n\t\t\tvar newArgs = currylessSlice(arguments);\n\t\t\tvar nextArgs = args.concat(newArgs);\n\t\t\treturn curryExecuteNext.call(this, processArgs, func, arity, nextArgs);\n\t\t};\n\t}\n};\n\n\nvar curryRight = function curryRight(func, arity) {\n\treturn curryExecuteNext.call(this, currylessReverse, func, arity, []);\n};\n\n\n// Curry left\nvar curry = function curry(func, arity) {\n\treturn curryExecuteNext.call(this, currylessIdentity, func, arity, []);\n};\n\n\nvar slice = curryRight(currylessSlice);\nvar others = slice(undefined);\nvar toArray = others(0);\nvar rest = others(1);\n\nfunction compose() {\n\tvar funcs = toArray(arguments);\n\n\treturn function composer() {\n\t\tvar args = arguments;\n\t\tvar func;\n\t\tfor (var index = funcs.length - 1; index >= 0; index -= 1) {\n\t\t\tfunc = funcs[index];\n\t\t\targs = [func.apply(null, args)];\n\t\t}\n\n\t\treturn args[0];\n\t};\n}\n\nvar negate = curry(function (func) {\n\treturn function () {\n\t\treturn !func.apply(this, arguments);\n\t};\n});\n\nvar reverse = curry(currylessReverse);\nvar identity = curry(currylessIdentity);\n\nvar constant = curry(function constant(value) {\n\treturn function () {\n\t\treturn value;\n\t};\n});\n\nfunction noop() {}\n\nvar exists = curry(curryLessExists);\n\nvar truthy = curry(function truthy(obj) {\n\treturn exists(obj) && obj !== false;\n});\n\nvar falsy = negate(truthy);\n\n\n// *** Type determination ***\n\nvar isOfType = curry(function isOfType(type, obj) {\n\treturn typeof obj === type;\n});\n\nvar isFunction = curry(function isFunction(obj) {\n    return !!(obj && obj.constructor && obj.call && obj.apply);\n});\n\nvar isObject = curry(function isObject(obj) {\n    return isFunction(obj) || (Boolean(obj) && isOfType(\"object\", obj));\n});\n\nvar isString = isOfType(\"string\");\nvar isNumber = curry(function (num) {\n\treturn isOfType(\"number\", num) && !isNaN(num);\n});\n\nvar isBoolean = isOfType(\"boolean\");\n\nvar prop = curry(function (key, obj) {\n\treturn obj[key];\n});\n\nmodule.exports = {\n\treverse: reverse,\n\tidentity: identity,\n\tconstant: constant,\n\tnoop: noop,\n\n\texists: exists,\n\tnegate: negate,\n\ttruthy: truthy,\n\tfalsy: falsy,\n\n\tisFunction: isFunction,\n\tisObject: isObject,\n\tisString: isString,\n\tisNumber: isNumber,\n\tisBoolean: isBoolean,\n\n\tslice: slice,\n\tothers: others,\n\trest: rest,\n\ttoArray: toArray,\n\tprop: prop,\n\n\tcurryRight: curryRight,\n\tcurry: curry,\n\n\tcompose: compose\n};",
    "\"use strict\";\n\nvar fn = require(\"./functional\");\n\nvar fold = fn.curry(function fold(iterator, initial, items) {\n\tvar memo = initial;\n\n\tfor(var key in items) {\n\t\tif (items.hasOwnProperty(key)) {\n\t\t\tmemo = iterator(memo, items[key], key);\n\t\t}\n\t}\n\n\treturn memo;\n});\n\nvar map = fn.curry(function map(iterator, items) {\n\n\treturn fold(function (memo, value, key) {\n\t\t\tvar result = iterator(value, key, items);\n\t\t\tmemo.push(result);\n\n\t\t\treturn memo;\n\t}, [], items);\n});\n\nvar select = fn.curry(function select(iterator, tuples) {\n\treturn fold(function (selection, tuple) {\n\t\tif (iterator(tuple)) {\n\t\t\tselection.push(tuple);\n\t\t}\n\n\t\treturn selection;\n\t}, [], tuples);\n});\n\nmodule.exports = {\n\tfold: fold,\n\tmap: map,\n\tselect: select,\n};",
    "\"use strict\";\n\nvar fn = require(\"./functional\");\n\nvar executeMethod = fn.curry(function executeMethod(context, method, args) {\n\treturn method.apply(context, args);\n});\n\nvar curryMethodInDirection = fn.curry(function curryMethodInDirection(processArgs, arity, method) {\n\tarity = fn.exists(arity) ? arity : method.length;\n\t// Plus 1 because context will be 1 extra argument\n\tarity +=1;\n\n\tvar curried = fn.curryRight(function (context) {\n\t\tvar args = processArgs(fn.rest(arguments));\n\n\t\treturn executeMethod(context, method, args);\n\n\t}, arity);\n\n\treturn curried.apply(null, fn.others(curryMethodInDirection.length, arguments));\n});\n\nvar curryMethodLeftWithArity = curryMethodInDirection(fn.reverse);\nvar curryMethodRightWithArity = curryMethodInDirection(fn.identity);\n\nvar curryMethodLeft = curryMethodLeftWithArity(undefined);\nvar curryMethodRight = curryMethodRightWithArity(undefined);\n\nmodule.exports = {\n\texecuteMethod: executeMethod,\n\tcurryMethodLeftWithArity: curryMethodLeftWithArity,\n\tcurryMethodRightWithArity: curryMethodRightWithArity,\n\tcurryMethodLeft: curryMethodLeft,\n\tcurryMethodRight: curryMethodRight\n};",
    "\"use strict\";\n\nvar fn = require(\"./functional\");\nvar methodCurry = require(\"./methodCurry\");\nvar iteration = require(\"./iteration\");\n\nvar getKey = fn.prop(0);\nvar getValue = fn.prop(1);\nvar isValueAFunction = fn.compose(fn.isFunction, getValue);\n\nvar toTuple = fn.curry(function toTuple(key, value) {\n\treturn [key, value];\n});\n\nvar toTuples = fn.curry(function toTuples(items) {\n\treturn iteration.fold(function (tuples, value, key) {\n\t\ttuples.push(toTuple(key, value));\n\t\treturn tuples;\n\t}, [], items);\n});\n\nvar toObject = fn.curry(function toObject(tuples) {\n\treturn iteration.fold(function (memo, tuple) {\n\t\tmemo[getKey(tuple)] = getValue(tuple);\n\t\treturn memo;\n\t}, {}, tuples);\n});\n\nvar curryMethodInDirection = fn.curry(function curryMethodInDirection(curryMethod, tuple) {\n\tvar key = getKey(tuple);\n\tvar method = curryMethod(getValue(tuple));\n\n\treturn toTuple(key, method);\n});\n\nvar curryMethodLeft = curryMethodInDirection(methodCurry.curryMethodLeft);\nvar curryMethodRight = curryMethodInDirection(methodCurry.curryMethodRight);\n\nmodule.exports = {\n\ttoTuple: toTuple,\n\ttoTuples: toTuples,\n\ttoObject: toObject,\n\tgetKey: getKey,\n\tgetValue: getValue,\n\tisValueAFunction: isValueAFunction,\n\tcurryMethodLeft: curryMethodLeft,\n\tcurryMethodRight: curryMethodRight\n};\n"
  ]
}